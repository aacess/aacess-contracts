{
    "language": "Solidity",
    "sources": {
        "./src/MegaMaskProduct.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.17;\n\n//------------------------\n//IMPORT EXTERNAL PACKAGES\n//------------------------\nimport {IMailbox} from \"./interfaces/IMailbox.sol\";\nimport {IInterchainGasPaymaster} from \"./interfaces/IInterchainGasPaymaster.sol\";\n\n/**\n * @title MegaMask\n * @dev A smart contract for managing product inventory and attestation on different chains.\n */\ncontract MegaMaskProduct {\n    //-----------------------------\n    //DEFINE VARIABLES & CONSTANTS\n    //-----------------------------\n    address public interchainGasPaymasterAddress;\n    address public mailboxAddress;\n    uint256 gasAmount = 100000;\n\n    IMailbox public mailbox;\n    IInterchainGasPaymaster public igp;\n    /**\n     * @dev Struct to store product details.\n     * @param productPicCID The CID of the uploaded image content of the product using web3.storage.\n     * @param productName The name of the product.\n     * @param price The price of the product.\n     */\n    struct Product {\n        string productPicCID;\n        string productName;\n        string price;\n    }\n\n    struct ChainIdToRecipientContractAddress {\n        uint32 chainId;\n        bytes32 contractAddress;\n    }\n\n    mapping(uint256 => ChainIdToRecipientContractAddress)\n        public chainIdToContractAddress;\n\n    uint256[] public chainIdsToPropagateTo;\n\n    /**\n     * @dev Mapping to store the product inventory based on the detected smart account address.\n     */\n    mapping(address => Product[]) public smartAccountToInventory; //gets the product inventory based on the detected smart account address\n\n    //-----------------------------\n    //DEFINE EVENTS\n    //-----------------------------\n\n    /**\n     * @dev Event triggered when a product is added to the inventory.\n     * @param smartAccountAddress The address of the smart account.\n     * @param productPicCID The CID of the uploaded image content of the product.\n     * @param productName The name of the product.\n     * @param price The price of the product.\n     */\n    event ProductAddedToOriginChain(\n        address indexed smartAccountAddress,\n        string productPicCID,\n        string productName,\n        string price,\n        uint256 index\n    );\n\n    // another event to say that the product details are propagated to different chains\n    event ProductPropagatedToDifferentChains(\n        address indexed smartAccountAddress,\n        uint256 indexed chainId,\n        string productPicCID,\n        string productName,\n        string price,\n        uint256 index\n    );\n\n    /**\n     * @dev Event triggered when a product is removed from the inventory.\n     * @param smartAccountAddress The address of the smart account.\n     * @param productPicCID The CID of the uploaded image content of the product.\n     * @param productName The name of the product.\n     * @param price The price of the product.\n     */\n    event ProductRemoved(\n        address indexed smartAccountAddress,\n        string productPicCID,\n        string productName,\n        string price\n    );\n\n    /**\n     * @dev Event triggered when the interchain gas paymaster address is updated.\n     * @param newInterchainGasPaymasterAddress The new interchain gas paymaster address.\n     */\n    event InterchainGasPaymasterUpdated(\n        address newInterchainGasPaymasterAddress\n    );\n\n    /**\n     * @dev Event triggered when the mailbox address is updated.\n     * @param newMailboxAddress The new mailbox address.\n     */\n    event MailboxUpdated(address newMailboxAddress);\n\n    //-----------------------------\n    //DEFINE MODIFIERS\n    //-----------------------------\n\n    //-----------------------------\n    //CONSTRUCTOR FUNCTION\n    //-----------------------------\n    constructor(\n        address _interchainGasPaymasterAddress,\n        address _mailboxAddress\n    ) {\n        interchainGasPaymasterAddress = _interchainGasPaymasterAddress;\n        mailboxAddress = _mailboxAddress;\n        _updateInstances(); // update the instances upon deployment\n    }\n\n    //-----------------------------\n    //DEFINE SETTER FUNCTIONS\n    //-----------------------------\n\n    //setter function to add product to inventory\n    function addProduct(\n        string memory _productPicCID,\n        string memory _productName,\n        string memory _price,\n        address _requestor\n    ) public {\n        //create a new product\n        Product memory newProduct = Product({\n            productPicCID: _productPicCID,\n            productName: _productName,\n            price: _price\n        });\n\n        //add the new product to the inventory\n        smartAccountToInventory[_requestor].push(newProduct);\n\n        //emit event and also mention which index the product is added to\n        emit ProductAddedToOriginChain(\n            _requestor,\n            _productPicCID,\n            _productName,\n            _price,\n            smartAccountToInventory[_requestor].length - 1\n        );\n    }\n\n    //-----------------------------\n    //DEFINE GETTER FUNCTIONS\n    //-----------------------------\n\n    //getter function to get the product inventory\n    function getProductInventory(\n        address _smartAccountAddress\n    ) public view returns (Product[] memory) {\n        return smartAccountToInventory[_smartAccountAddress];\n    }\n\n    //getter function to get the product details\n    function getProduct(\n        address _smartAccountAddress,\n        uint256 _productIndex\n    ) public view returns (Product memory) {\n        return smartAccountToInventory[_smartAccountAddress][_productIndex];\n    }\n\n    //-------------------------\n    //DEFINE INTERNAL FUNCTIONS\n    //-------------------------\n    function _updateInstances() internal {\n        mailbox = IMailbox(mailboxAddress);\n        igp = IInterchainGasPaymaster(interchainGasPaymasterAddress);\n    }\n\n    //-------------------------\n    //DEFINE EXTERNAL FUNCTIONS\n    //-------------------------\n    //change the gas amount\n    function changeGasAmount(uint256 _gasAmount) external {\n        gasAmount = _gasAmount;\n    }\n\n    //change the interchain gas paymaster address\n    function changeInterchainGasPaymasterAddress(\n        address _interchainGasPaymasterAddress\n    ) external {\n        interchainGasPaymasterAddress = _interchainGasPaymasterAddress;\n        emit InterchainGasPaymasterUpdated(_interchainGasPaymasterAddress);\n        _updateInstances(); // Update instances after changing the address\n    }\n\n    //change the mailbox address\n    function changeMailboxAddress(address _mailboxAddress) external {\n        mailboxAddress = _mailboxAddress;\n        emit MailboxUpdated(_mailboxAddress);\n        _updateInstances(); // Update instances after changing the address\n    }\n\n    //setter function to update the chain ids to propagate to, use the array to get the latest index to update the mapping\n    function addChainIdToPropagateTo(\n        uint32 _chainId,\n        bytes32 _recipientContractAddress\n    ) external {\n        //check if the chain id already exists in the array\n        for (uint256 i = 0; i < chainIdsToPropagateTo.length; i++) {\n            //check if the chain id already exists in the array\n            require(\n                chainIdsToPropagateTo[i] != _chainId,\n                \"Chain ID already exists in the array\"\n            );\n        }\n\n        //add the chain id to the array\n        chainIdsToPropagateTo.push(_chainId);\n\n        //add the chain id and the contract address to the mapping\n        chainIdToContractAddress[\n            chainIdsToPropagateTo.length\n        ] = ChainIdToRecipientContractAddress({\n            chainId: _chainId,\n            contractAddress: _recipientContractAddress\n        });\n    }\n\n    //function to update the chain id to contract address mapping\n    function updateChainIdToContractAddress(\n        uint256 _index,\n        uint32 _chainId,\n        bytes32 _recipientContractAddress\n    ) external {\n        //update the chain id to contract address mapping\n        chainIdToContractAddress[_index] = ChainIdToRecipientContractAddress({\n            chainId: _chainId,\n            contractAddress: _recipientContractAddress\n        });\n    }\n\n    //function to propagate to other chains other than the origin chain, it accepts the origin chain ID so it knows which to skip, and also the product index\n    function propagateToOtherChains(\n        uint32 _originChainId,\n        bytes calldata _data\n    ) external {\n        //loop through the chain ids to propagate to\n        for (uint256 i = 1; i <= chainIdsToPropagateTo.length; i++) {\n            //check if the chain id is not the origin chain id\n            if (chainIdToContractAddress[i].chainId != _originChainId) {\n                //call the sendInterchainCall function to send the interchain call\n                sendInterchainCall(\n                    chainIdToContractAddress[i].chainId,\n                    chainIdToContractAddress[i].contractAddress,\n                    _data\n                );\n            }\n        }\n    }\n\n    //this is used to call AttestRecipient contract on Arbitrum Goerli\n    function sendInterchainCall(\n        uint32 _destinationDomain,\n        bytes32 _recipientAddress,\n        bytes calldata _messageBody\n    ) public {\n        _updateInstances(); // Ensure instances are up-to-date\n        bytes32 messageId = mailbox.dispatch(\n            _destinationDomain,\n            _recipientAddress,\n            _messageBody\n        );\n\n        // Get the required payment from the IGP.\n        uint256 quote = igp.quoteGasPayment(_destinationDomain, gasAmount);\n\n        igp.payForGas{value: quote}(\n            messageId, // The ID of the message that was just dispatched\n            _destinationDomain, // The destination domain of the message\n            gasAmount, // 550k gas to use in the recipient's handle function\n            address(this) // refunds go to msg.sender, who paid the msg.value\n        );\n    }\n\n    //transfer function to transfer the funds to another contract\n    function transferFunds(address payable _to, uint256 _amount) external {\n        _to.transfer(_amount);\n    }\n\n    //get contract balance\n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    //get the list of chain ids to propagate to\n    function getChainIdsToPropagateTo()\n        external\n        view\n        returns (uint256[] memory)\n    {\n        return chainIdsToPropagateTo;\n    }\n\n    //get the chain id to contract address mapping\n    function getChainIdToContractAddress(\n        uint256 _index\n    ) external view returns (ChainIdToRecipientContractAddress memory) {\n        return chainIdToContractAddress[_index];\n    }\n\n    receive() external payable {}\n}\n"
        },
        "./src/interfaces/IMailbox.sol": {
            "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.0;\n\nimport {IInterchainSecurityModule} from \"./IInterchainSecurityModule.sol\";\n\ninterface IMailbox {\n    // ============ Events ============\n    /**\n     * @notice Emitted when a new message is dispatched via Hyperlane\n     * @param sender The address that dispatched the message\n     * @param destination The destination domain of the message\n     * @param recipient The message recipient address on `destination`\n     * @param message Raw bytes of message\n     */\n    event Dispatch(\n        address indexed sender,\n        uint32 indexed destination,\n        bytes32 indexed recipient,\n        bytes message\n    );\n\n    /**\n     * @notice Emitted when a new message is dispatched via Hyperlane\n     * @param messageId The unique message identifier\n     */\n    event DispatchId(bytes32 indexed messageId);\n\n    /**\n     * @notice Emitted when a Hyperlane message is processed\n     * @param messageId The unique message identifier\n     */\n    event ProcessId(bytes32 indexed messageId);\n\n    /**\n     * @notice Emitted when a Hyperlane message is delivered\n     * @param origin The origin domain of the message\n     * @param sender The message sender address on `origin`\n     * @param recipient The address that handled the message\n     */\n    event Process(\n        uint32 indexed origin,\n        bytes32 indexed sender,\n        address indexed recipient\n    );\n\n    function localDomain() external view returns (uint32);\n\n    function delivered(bytes32 messageId) external view returns (bool);\n\n    function defaultIsm() external view returns (IInterchainSecurityModule);\n\n    function dispatch(\n        uint32 _destinationDomain,\n        bytes32 _recipientAddress,\n        bytes calldata _messageBody\n    ) external returns (bytes32);\n\n    function process(\n        bytes calldata _metadata,\n        bytes calldata _message\n    ) external;\n\n    function count() external view returns (uint32);\n\n    function root() external view returns (bytes32);\n\n    function latestCheckpoint() external view returns (bytes32, uint32);\n\n    function recipientIsm(\n        address _recipient\n    ) external view returns (IInterchainSecurityModule);\n}\n"
        },
        "./src/interfaces/IInterchainSecurityModule.sol": {
            "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\ninterface IInterchainSecurityModule {\n    enum Types {\n        UNUSED,\n        ROUTING,\n        AGGREGATION,\n        LEGACY_MULTISIG,\n        MERKLE_ROOT_MULTISIG,\n        MESSAGE_ID_MULTISIG,\n        NULL, // used with relayer carrying no metadata\n        CCIP_READ\n    }\n\n    /**\n     * @notice Returns an enum that represents the type of security model\n     * encoded by this ISM.\n     * @dev Relayers infer how to fetch and format metadata.\n     */\n    function moduleType() external view returns (uint8);\n\n    /**\n     * @notice Defines a security model responsible for verifying interchain\n     * messages based on the provided metadata.\n     * @param _metadata Off-chain metadata provided by a relayer, specific to\n     * the security model encoded by the module (e.g. validator signatures)\n     * @param _message Hyperlane encoded interchain message\n     * @return True if the message was verified\n     */\n    function verify(\n        bytes calldata _metadata,\n        bytes calldata _message\n    ) external returns (bool);\n}\n\ninterface ISpecifiesInterchainSecurityModule {\n    function interchainSecurityModule()\n        external\n        view\n        returns (IInterchainSecurityModule);\n}\n"
        },
        "./src/interfaces/IInterchainGasPaymaster.sol": {
            "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n/**\n * @title IInterchainGasPaymaster\n * @notice Manages payments on a source chain to cover gas costs of relaying\n * messages to destination chains.\n */\ninterface IInterchainGasPaymaster {\n    /**\n     * @notice Emitted when a payment is made for a message's gas costs.\n     * @param messageId The ID of the message to pay for.\n     * @param gasAmount The amount of destination gas paid for.\n     * @param payment The amount of native tokens paid.\n     */\n    event GasPayment(\n        bytes32 indexed messageId,\n        uint256 gasAmount,\n        uint256 payment\n    );\n\n    function payForGas(\n        bytes32 _messageId,\n        uint32 _destinationDomain,\n        uint256 _gasAmount,\n        address _refundAddress\n    ) external payable;\n\n    function quoteGasPayment(\n        uint32 _destinationDomain,\n        uint256 _gasAmount\n    ) external view returns (uint256);\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}